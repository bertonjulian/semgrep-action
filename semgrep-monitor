#!/usr/bin/env python3
import argparse
import json
import os
from pathlib import Path
import subprocess
import sys
from typing import Any, Dict, List

import requests


def url(string: str) -> str:
    return string.rstrip("/")


parser = argparse.ArgumentParser(
    prog="semgrep-monitor", description="Notify about Semgrep results."
)
parser.add_argument("--semgrep-app-url", type=url, help="Semgrep app URL")
parser.add_argument("--semgrep-app-token", type=str, help="Semgrep app auth token")

subparsers = parser.add_subparsers(help="Event to report")

parser_start = subparsers.add_parser(
    "start", help="Report that a scan is being started"
)
parser_start.add_argument("deployment_id", type=int, help="Semgrep app deployment ID")

parser_finish = subparsers.add_parser(
    "finish", help="Report results of a finished scan"
)

parser_finish.add_argument("exitcode", type=int, help="Semgrep's exit code")
parser_finish.add_argument(
    "results_file", type=argparse.FileType("r"), help="Path to Semgrep's JSON output"
)

parser_finish.add_argument("--slack-url", type=url, help="Slack webhook URL")
parser_finish.add_argument("--scan-id", type=int, help="Semgrep app scan ID")


repo_name = os.environ["GITHUB_REPOSITORY"]
repo_url = f"https://github.com/{repo_name}"
action_url = f"{repo_url}/actions/runs/{os.environ['GITHUB_RUN_ID']}"


def generate_message(notify_reason: str) -> List[Dict[str, Any]]:
    return [
        {
            "type": "section",
            "text": {
                "type": "mrkdwn",
                "text": f":point_right: Semgrep Action {notify_reason} during *<{action_url}|a scan on {repo_name}>*",
            },
        },
        {
            "type": "section",
            "fields": [
                {"type": "mrkdwn", "text": f"*Repo:*\n<{repo_url}|{repo_name}>"},
                {
                    "type": "mrkdwn",
                    "text": f"*Triggered by:*\n{os.environ['GITHUB_ACTOR']}",
                },
                {
                    "type": "mrkdwn",
                    "text": f"*Scanned git ref:*\n`{os.environ['GITHUB_REF']}`",
                },
                {
                    "type": "mrkdwn",
                    "text": f"*Scanned git SHA:*\n`{os.environ['GITHUB_SHA'][:8]}`",
                },
            ],
        },
    ]


def report_start_to_semgrep_app():
    if not args.semgrep_app_token:
        return

    api_url = f"{args.semgrep_app_url}/api/agent/deployment/{args.deployment_id}/scan"
    metadata = {
        "repository": repo_name,
        "commit": os.environ["GITHUB_SHA"],
        "on": os.environ["GITHUB_EVENT_NAME"],
        "branch": os.environ["GITHUB_REF"],
    }
    try:
        response = requests.post(
            api_url,
            headers={"Authorization": f"Bearer {args.semgrep_app_token}"},
            json={"meta": metadata},
        )
        response.raise_for_status()
    except requests.RequestException:
        print(f"Semgrep App returned this error: {response.text}", file=sys.stderr)
    else:
        print(response.json()["scan"]["id"])


def report_finish():
    report_finish_to_slack()
    report_finish_to_semgrep_app()


def report_finish_to_slack():
    if not args.slack_url:
        return

    print("== sending slack notifications if needed", file=sys.stderr)

    notify_reason = None
    if args.exitcode == 2:
        notify_reason = "found issues"
    elif args.exitcode != 0:
        notify_reason = "encountered an error"

    if not notify_reason:
        print(
            "not sending a notification, there's nothing to notify about",
            file=sys.stderr,
        )
        return

    payload = {
        "text": f"Semgrep Action {notify_reason} during a scan on {repo_name}",
        "blocks": generate_message(notify_reason),
        "icon_emoji": ":mag_right:",
        "username": "Semgrep",
    }
    try:
        response = requests.post(args.slack_url, data={"payload": json.dumps(payload)},)
        response.raise_for_status()
    except requests.RequestException:
        print(f"Slack returned this error: {response.text}", file=sys.stderr)


def report_finish_to_semgrep_app():
    if not args.semgrep_app_token:
        return

    # send findings
    results = json.load(args.results_file)
    payload = [
        {
            "path": result["path"],
            "rule": result["check_id"],
            "startLine": result["line"],
            "endLine": result["line"],  # TODO get end line from semgrep
        }
        for result in results
    ]
    api_url = f"{args.semgrep_app_url}/api/agent/scan/{args.scan_id}/findings"
    try:
        response = requests.post(
            api_url,
            headers={"Authorization": f"Bearer {args.semgrep_app_token}"},
            json=payload,
        )
        response.raise_for_status()
    except requests.RequestException:
        print(f"Semgrep App returned this error: {response.text}", file=sys.stderr)

    # mark as complete
    stats = {
        "findings": len(results)
    }  # TODO: {â€¦, "files_scanned": 552, "total_time": 1.34, "cpu_time": 4.32}
    api_url = f"{args.semgrep_app_url}/api/agent/scan/{args.scan_id}/complete"
    try:
        response = requests.post(
            api_url,
            headers={"Authorization": f"Bearer {args.semgrep_app_token}"},
            json={"exit_code": args.exitcode, "stats": stats},
        )
        response.raise_for_status()
    except requests.RequestException:
        print(f"Semgrep App returned this error: {response.text}", file=sys.stderr)


parser_start.set_defaults(handler=report_start_to_semgrep_app)
parser_finish.set_defaults(handler=report_finish)

if __name__ == "__main__":
    args = parser.parse_args()
    args.handler()
